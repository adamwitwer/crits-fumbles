<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="description" content="A fantasy dice-rolling app for critical hits and fumbles.">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="robots" content="noindex, nofollow">
    <title>Crits & Fumbles</title>

    <link rel="icon" href="{{ url_for('static', filename='favicon.svg') }}" sizes="any" type="image/svg+xml">
    <link rel="icon" href="{{ url_for('static', filename='favicon.ico') }}" sizes="48x48">
    <link rel="apple-touch-icon" sizes="180x180" href="{{ url_for('static', filename='apple-touch-icon.png') }}">

    <meta name="theme-color" content="#c19a6b">
    <meta name="theme-color" content="#1e1e1e" media="(prefers-color-scheme: dark)">
    <meta name="apple-mobile-web-app-title" content="Crits & Fumbles">
    <link rel="manifest" href="{{ url_for('static', filename='site.webmanifest') }}">

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Merriweather:ital,opsz,wght@0,18..144,300..900;1,18..144,300..900&family=Uncial+Antiqua&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
</head>
<body>

<h1>Crits & Fumbles</h1>

<form id="main-form">
  <div>
    <label for="roll_type">Roll Type</label>
    <select name="roll_type" id="roll_type" onchange="toggleFields()">
      <option value="crit" {% if selected_roll_type == 'crit' %}selected{% endif %}>Critical</option>
      <option value="fumble" {% if selected_roll_type == 'fumble' %}selected{% endif %}>Fumble</option>
    </select>
  </div>

  <div id="crit-source-container" style="display:none;">
    <label for="crit_source">Crit Type</label><span class="info-icon" id="crit_source_info_icon" style="display:none;" title="About this crit source">‚ìò</span>
    <select name="crit_source" id="crit_source">
      <option value="Sterling Vermin" {% if selected_crit_source == 'Sterling Vermin' %}selected{% endif %}>Sterling Vermin</option>
      <option value="Questionable Arcana" {% if selected_crit_source == 'Questionable Arcana' %}selected{% endif %}>Questionable Arcana</option>
      <option value="BCoydog" {% if selected_crit_source == 'BCoydog' %}selected{% endif %}>u/BCoydog</option>
    </select>
    <div id="crit-fields" style="display:none;">
      <div>
        <label for="damage_type">Damage Type</label>
        <select name="damage_type" id="damage_type" onchange="toggleMagicDropdown()">
          {# Options populated by JavaScript #}
        </select>
      </div>
      <div id="magic-subtype" style="display: none;">
        <label for="magic_subtype">Magic Type</label>
        <select name="magic_subtype" id="magic_subtype">
          {# Options populated by JavaScript #}
        </select>
      </div>
    </div>
  </div>

  <div id="fumble-type-container" style="display:none;">
    <label for="fumbleType">Fumble Type</label><span class="info-icon" id="fumble_type_info_icon" style="display:none;" title="About this fumble source">‚ìò</span>
    <select id="fumbleType" name="fumbleType" onchange="toggleAttackType()">
      <option value="Questionable Arcana" {% if selected_fumble_type == 'Questionable Arcana' %}selected{% endif %}>Questionable Arcana</option>
      <option value="BCoydog" {% if selected_fumble_type == 'BCoydog' %}selected{% endif %}>u/BCoydog</option>
    </select>
    <div id="attack-type-container" style="display:none;">
      <label for="attackType">Attack Type</label>
      <select id="attackType" name="attackType">
        <option value="Weapon" {% if selected_attack_type == 'Weapon' %}selected{% endif %}>Weapon</option>
        <option value="Magic" {% if selected_attack_type == 'Magic' %}selected{% endif %}>Magic</option>
      </select>
    </div>
  </div>

  <button type="button" id="primary-roll-button" onclick="handleRoll('primary')" aria-label="Roll dice for result">‚ö°Ô∏è Roll ‚ö°Ô∏è</button>

</form>

<div id="error-message" style="display: none; color: red; text-align: center; margin: 1rem 0;"></div>
<div id="primary-result-area" style="display: none;"></div>
<div id="secondary-prompt-area" style="display: none;" class="bonus-alert">
    <h2 id="secondary-prompt-text"></h2>
    <input type="hidden" id="secondary-roll-type-hidden">
    <input type="hidden" id="secondary-crit-source-hidden">
    <input type="hidden" id="secondary-damage-type-hidden">
    <input type="hidden" id="secondary-magic-subtype-hidden">
    <input type="hidden" id="secondary-primary-result-hidden">
    <input type="hidden" id="secondary-primary-roll-hidden">
    <button type="button" id="secondary-roll-button" onclick="handleRoll('secondary')" aria-label="Roll dice for bonus effect">‚ö°Ô∏è Roll Bonus ‚ö°Ô∏è</button>
</div>
<div id="secondary-result-area" style="display: none;"></div>

<div class="share-container"><button type="button" id="share-discord-button" onclick="shareResultToDiscord()" style="display: none;">
  <img src="{{ url_for('static', filename='img/discord-icon.svg') }}" alt="Discord Logo" class="discord-icon">
  <span class="button-text">Share Result to Discord</span></button>
</div>

<audio id="dice-sound" preload="auto">
    <source src="{{ url_for('static', filename='sounds/dice-roll.mp3') }}" type="audio/mpeg">
    Your browser does not support the audio element.
</audio>
<div id="dice-animation-overlay"></div>

<div id="info-modal-overlay" class="modal-overlay">
  <div id="info-modal" class="modal-content">
    <div id="info-modal-close-button" class="modal-close-button" aria-label="Close modal"></div>
    <h2 id="info-modal-title">Source Information</h2>
    <p id="info-modal-text">Information will appear here.</p>
  </div>
</div>

<div id="history-overlay">
  <div id="history-modal">
    <div id="close-history-modal" aria-label="Close Chronicles"></div>
    <div class="history-header"><h2>Chronicles</h2></div>
    <div id="history-content"></div>
  </div>
</div> 

<footer class="app-footer">
  <p>
    Made with üé≤ by Adam |
    <a href="https://github.com/adamwitwer/crits-fumbles" target="_blank" rel="noopener" aria-label="GitHub Repository">
      <svg class="github-icon" viewBox="0 0 24 24" aria-hidden="true" focusable="false"><path fill="currentColor" d="M12 0C5.37 0 0 5.373 0 12c0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577v-2.17c-3.338.726-4.033-1.416-4.033-1.416-.546-1.386-1.333-1.756-1.333-1.756-1.09-.745.083-.729.083-.729 1.205.084 1.84 1.237 1.84 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.776.42-1.304.762-1.603-2.665-.305-5.466-1.334-5.466-5.933 0-1.31.47-2.38 1.235-3.22-.124-.303-.535-1.527.117-3.176 0 0 1.008-.322 3.3 1.23.957-.266 1.98-.399 3-.404 1.02.005 2.043.138 3 .404 2.29-1.552 3.296-1.23 3.296-1.23.653 1.649.242 2.873.118 3.176.767.84 1.233 1.91 1.233 3.22 0 4.61-2.804 5.625-5.475 5.922.43.37.823 1.103.823 2.222v3.293c0 .322.218.694.825.576C20.565 21.796 24 17.298 24 12c0-6.627-5.373-12-12-12z" /></svg>
    </a>
  </p>
  <p class="history-button-container">
    <a id="show-history-button" class="subtle-button">üìú C&F Chronicles</a>
  </p>
</footer>

<script>
  // --- Global Elements ---
  const diceAudio = document.getElementById('dice-sound');
  const primaryRollBtn = document.getElementById('primary-roll-button');
  const secondaryRollBtn = document.getElementById('secondary-roll-button');
  const errorMessageDiv = document.getElementById('error-message');
  const primaryResultArea = document.getElementById('primary-result-area');
  const secondaryPromptArea = document.getElementById('secondary-prompt-area');
  const secondaryResultArea = document.getElementById('secondary-result-area');
  const shareButton = document.getElementById('share-discord-button');

  // --- Modal Elements ---
  const infoModalOverlay = document.getElementById('info-modal-overlay');
  const infoModalTextElement = document.getElementById('info-modal-text');
  const infoModalTitleElement = document.getElementById('info-modal-title');
  const infoModalCloseButton = document.getElementById('info-modal-close-button');
  const critSourceInfoIcon = document.getElementById('crit_source_info_icon');
  const fumbleTypeInfoIcon = document.getElementById('fumble_type_info_icon');

  // --- Data for Dynamic Dropdowns & Info Modals ---
  const critSourceDamageTypes = {
      "Sterling Vermin": {
          options: ["bludgeoning", "piercing", "slashing", "magic"],
          magicSubtypes: {
              "magic:acid": "Acid", "magic:cold": "Cold", "magic:fire": "Fire",
              "magic:force": "Force", "magic:lightning": "Lightning", "magic:necrotic": "Necrotic",
              "magic:poison": "Poison", "magic:psychic": "Psychic", "magic:radiant": "Radiant",
              "magic:thunder": "Thunder"
          }
      },
      "Questionable Arcana": { options: ["weapon", "spell"], magicSubtypes: {} },
      "BCoydog": { options: ["melee", "ranged", "magic"], magicSubtypes: {} }
  };

  const sourceInfoTexts = {
      critSources: {
          "Sterling Vermin": "<a target='_blank' rel='noopener noreferrer' href='https://sterlingvermin.wordpress.com/2016/09/27/critical-hits-revisited/'>Critical Hits Revisited</a> offers d20 results with comprehensive damage types, including magic subtypes and insanities.",
          "Questionable Arcana": "These d100 critical hit tables from <a target='_blank' rel='noopener noreferrer' href='https://growupandgame.com/dungeons-and-dragons/questionable-arcana/dnd-5e-crit-confirmed-critical-hit-charts-and-fumble-charts/'>Questionable Arcana</a> provide narrative and situational effects, often with a unique twist. They are broadly categorized (e.g., Weapon, Spell) and complemented by the QA fumble tables.",
          "BCoydog": "Reddit user u/BCoydog shared these critical hit tables in <a target='_blank' rel='noopener noreferrer' href'https://www.reddit.com/r/DnD/comments/1cuzgxf/critical_hit_fumble_d100_tables_with_51_results/'>the DnD subreddit</a>. Expect wild (but fair) outcomes for melee, ranged, and magic attacks, often with detailed descriptions and mechanical impacts. Accompanied by a fumble table."
      },
      fumbleSources: {
          "Questionable Arcana": "The <a target='_blank' rel='noopener noreferrer' href='https://growupandgame.com/dungeons-and-dragons/questionable-arcana/dnd-5e-crit-confirmed-critical-hit-charts-and-fumble-charts/'>Questionable Arcana</a> d100 fumble tables focus on the story consequences of fumbled weapon or spell attacks.",
          "BCoydog": "Reddit user u/BCoydog‚Äôs <a target='_blank' rel='noopener noreferrer' href='https://www.reddit.com/r/DnD/comments/1cuzgxf/critical_hit_fumble_d100_tables_with_51_results/'>d100 fumble tables</a> feature humorous or challenging results for fumbled melee, ranged, or magic actions."
      }
  };

  // --- Modal Functions ---
  function showInfoModal(typeKey, sourceName) { // typeKey is 'critSources' or 'fumbleSources'
      const infoText = sourceInfoTexts[typeKey]?.[sourceName];
      if (infoText && infoModalOverlay && infoModalTextElement && infoModalTitleElement) {
          infoModalTextElement.innerHTML = infoText;
          infoModalTitleElement.textContent = `${sourceName}`;
          infoModalOverlay.classList.add('active');
      } else {
          console.warn("No info text found for:", typeKey, sourceName);
          infoModalTextElement.textContent = "Information not available for this selection.";
          infoModalTitleElement.textContent = "Information";
          infoModalOverlay.classList.add('active');
      }
  }

  function hideInfoModal() {
      if (infoModalOverlay) {
          infoModalOverlay.classList.remove('active');
      }
  }
  
  // --- UI Toggle Functions ---
  // START BUG FIX MODIFICATION for toggleAttackType
  function toggleAttackType() {
    const fumbleTypeSelect = document.getElementById('fumbleType');
    const selectedFumbleType = fumbleTypeSelect.value;
    const attackTypeContainer = document.getElementById('attack-type-container');
    const attackTypeSelect = document.getElementById('attackType');
    const rollType = document.getElementById('roll_type').value;

    // Preserve current value if it's valid for the new set of options
    const currentAttackTypeValue = attackTypeSelect.value;

    attackTypeSelect.innerHTML = ''; // Clear existing options

    if (rollType === 'fumble') {
        let newOptions = [];
        if (selectedFumbleType === "Questionable Arcana") {
            newOptions = [
                { value: "Weapon", text: "Weapon" },
                { value: "Magic", text: "Magic" }
            ];
            attackTypeContainer.style.display = 'block';
        } else if (selectedFumbleType === "BCoydog") {
            newOptions = [
                { value: "melee", text: "Melee" },
                { value: "ranged", text: "Ranged" },
                { value: "magic", text: "Magic" }
            ];
            attackTypeContainer.style.display = 'block';
        } else {
            attackTypeContainer.style.display = 'none';
        }

        let valueToSet = null;
        newOptions.forEach(opt => {
            const option = document.createElement('option');
            option.value = opt.value;
            option.textContent = opt.text;
            attackTypeSelect.appendChild(option);
            if (opt.value === currentAttackTypeValue) {
                valueToSet = currentAttackTypeValue;
            }
        });

        if (valueToSet) {
            attackTypeSelect.value = valueToSet;
        } else if (attackTypeSelect.options.length > 0) {
            attackTypeSelect.value = attackTypeSelect.options[0].value;
        }

    } else {
        attackTypeContainer.style.display = 'none';
    }
  }
  // END BUG FIX MODIFICATION for toggleAttackType

  function toggleFields() {
    const rollType = document.getElementById('roll_type').value;
    const critFields = document.getElementById('crit-fields');
    const fumbleTypeContainer = document.getElementById('fumble-type-container');
    const attackTypeContainer = document.getElementById('attack-type-container'); // Keep this line
    const critSourceContainer = document.getElementById('crit-source-container');
    // Info Icons
    const currentCritSourceInfoIcon = document.getElementById('crit_source_info_icon');
    const currentFumbleTypeInfoIcon = document.getElementById('fumble_type_info_icon');


    if (rollType === 'fumble') {
      critFields.style.display = 'none';
      critSourceContainer.style.display = 'none';
      if(currentCritSourceInfoIcon) currentCritSourceInfoIcon.style.display = 'none';
      
      fumbleTypeContainer.style.display = 'block';
      if(currentFumbleTypeInfoIcon) currentFumbleTypeInfoIcon.style.display = 'inline-block'; 
      toggleAttackType(); // This will correctly set up the attackType dropdown based on the selected fumbleType
    } else { // crit
      critFields.style.display = 'block';
      critSourceContainer.style.display = 'block';
      if(currentCritSourceInfoIcon) currentCritSourceInfoIcon.style.display = 'inline-block'; 
      
      fumbleTypeContainer.style.display = 'none';
      if(currentFumbleTypeInfoIcon) currentFumbleTypeInfoIcon.style.display = 'none';
      attackTypeContainer.style.display = 'none'; // Ensure it's hidden when not fumble
      updateDamageAndMagicTypes(); 
    }
  }
  
  // --- Helper: Sound Function ---
  function playDiceSound() {
    if (diceAudio) {
      diceAudio.currentTime = 0;
      diceAudio.play().catch(error => console.error("Audio play failed:", error));
    }
  }

  // --- Helper: Create Final Roll HTML (with number) ---
  function createRollHTML(rollValue, numDice, dieType) {
      let html = '<div class="roll-result">';
      const rollValueSpan = `<span class="roll-value">${rollValue || '?'}</span>`;

      if (dieType === 'd100' && numDice === 1) {
          const d10ImageSrc = "{{ url_for('static', filename='img/d10.png') }}";
          const d10AltText = 'd10';
          html += `<img src="${d10ImageSrc}" alt="${d10AltText}" class="inline-die" />`; 
          html += rollValueSpan;
          html += `<img src="${d10ImageSrc}" alt="${d10AltText}" class="inline-die" />`; 
      } else {
          const dieImageFilename = (dieType || 'd20') + '.png';
          const dieImageSrc = "{{ url_for('static', filename='img/') }}" + dieImageFilename;
          const dieAltText = dieType || 'd20';
          html += `<img src="${dieImageSrc}" alt="${dieAltText}" class="inline-die" />`;
          html += rollValueSpan;
      }
      html += '</div>';
      return html;
  }

  // --- Helper: Format Keywords ---
  function formatKeywords(text) {
      if (!text) return "";
      const keywordClass = "keyword-prefix";
      let formattedText = text.replaceAll("Melee:", `<span class="${keywordClass}">Melee:</span>`);
      formattedText = formattedText.replaceAll("Ranged:", `<br><br><span class="${keywordClass}">Ranged:</span>`);
      return formattedText;
  }

  // --- Helper: Display Rolling Animation ---
  function displayRollingAnimation(dieType, numDice) {
      const overlay = document.getElementById('dice-animation-overlay');
      let animContainer = overlay.querySelector('.rolling-animation-container');
      if (!animContainer) {
          animContainer = document.createElement('div');
          animContainer.classList.add('rolling-animation-container');
          overlay.appendChild(animContainer);
      } else {
          animContainer.innerHTML = '';
      }

      let actualNumDiceForAnim = numDice;
      let actualDieTypeForAnim = dieType;
      if (dieType === 'd100' && numDice === 1) { 
          actualDieTypeForAnim = 'd10'; 
          actualNumDiceForAnim = 2;     
      }
      
      const dieImageFilename = actualDieTypeForAnim + '.png';
      const dieImageSrc = "{{ url_for('static', filename='img/') }}" + dieImageFilename;
      const dieAltText = actualDieTypeForAnim;

      for (let i = 0; i < actualNumDiceForAnim; i++) {
          const img = document.createElement('img');
          img.src = dieImageSrc;
          img.alt = dieAltText;
          img.classList.add('inline-die', 'is-rolling');
          animContainer.appendChild(img);
      }
      overlay.style.display = 'flex';
  }

  // --- Helper: Update Damage Type and Magic Subtype Dropdowns ---
   function updateDamageAndMagicTypes() {
       const critSource = document.getElementById('crit_source').value;
       const damageTypeSelect = document.getElementById('damage_type');
       const magicSubtypeContainer = document.getElementById('magic-subtype');
       const magicSubtypeSelect = document.getElementById('magic_subtype');

       damageTypeSelect.innerHTML = '';
       magicSubtypeSelect.innerHTML = '';
       magicSubtypeContainer.style.display = 'none';

       const sourceData = critSourceDamageTypes[critSource];

       if (sourceData) {
           sourceData.options.forEach(type => {
               const option = document.createElement('option');
               option.value = type; 
               option.textContent = type.charAt(0).toUpperCase() + type.slice(1); 
               damageTypeSelect.appendChild(option);
           });
           toggleMagicDropdown(); 
       } else {
           const option = document.createElement('option');
           option.value = "";
           option.textContent = "Select Crit Source";
           damageTypeSelect.appendChild(option);
       }
   }

  // --- Helper: Toggle Magic Subtype Dropdown ---
  function toggleMagicDropdown() {
    const critSource = document.getElementById('crit_source').value;
    const damageType = document.getElementById('damage_type').value; 
    const magicSubtypeContainer = document.getElementById('magic-subtype');
    const magicSubtypeSelect = document.getElementById('magic_subtype');

    magicSubtypeContainer.style.display = 'none';
    magicSubtypeSelect.innerHTML = '';

    if (critSource === "Sterling Vermin" && damageType === "magic") {
        const sterlingVerminMagicSubtypes = critSourceDamageTypes["Sterling Vermin"].magicSubtypes;
        if (sterlingVerminMagicSubtypes) {
            for (const key in sterlingVerminMagicSubtypes) { 
                const option = document.createElement('option');
                option.value = key; 
                option.textContent = sterlingVerminMagicSubtypes[key]; 
                magicSubtypeSelect.appendChild(option);
            }
            magicSubtypeContainer.style.display = 'block';
        }
    }
  }

  // --- Main Roll Handler (AJAX) ---
  async function handleRoll(context) {
      playDiceSound();
      errorMessageDiv.style.display = 'none';
      errorMessageDiv.textContent = '';
      primaryRollBtn.disabled = true;
      secondaryRollBtn.disabled = true;
      if (shareButton) {
          shareButton.disabled = true;
          const buttonTextSpan = shareButton.querySelector('.button-text');
          if (buttonTextSpan && buttonTextSpan.textContent === "Shared!") {
              const discordIconHTML = '<img src="{{ url_for('static', filename='img/discord-icon.svg') }}" alt="Discord Logo" class="discord-icon">';
              shareButton.innerHTML = `${discordIconHTML} <span class="button-text">Share Result to Discord</span>`;
          }
      }

      primaryResultArea.innerHTML = '';
      primaryResultArea.style.visibility = 'hidden';
      secondaryResultArea.innerHTML = '';
      secondaryResultArea.style.visibility = 'hidden';
      if (secondaryPromptArea) secondaryPromptArea.style.display = 'none';

      let payload = { rollContext: context };
      let dieTypeForAnim, numDiceForAnim;

      if (context === 'primary') {
          payload.rollType = document.getElementById('roll_type').value;
          const critSource = document.getElementById('crit_source').value;

          if (payload.rollType === 'crit') {
              payload.critSource = critSource;
              let selectedDamageType = document.getElementById('damage_type').value;
              payload.damageType = selectedDamageType; 

              if (critSource === "Sterling Vermin" && selectedDamageType === "magic") {
                  payload.magicSubtype = document.getElementById('magic_subtype').value; 
              }
              
              if (critSource === "Questionable Arcana" || critSource === "BCoydog") {
                  dieTypeForAnim = 'd100'; 
                  numDiceForAnim = 1;      
              } else { // Sterling Vermin crits
                  dieTypeForAnim = 'd20';
                  numDiceForAnim = 1;
              }
          } else { // fumble
              payload.fumbleType = document.getElementById('fumbleType').value; 
              payload.attackType = document.getElementById('attackType').value; 
              dieTypeForAnim = 'd100'; 
              numDiceForAnim = 1;      
          }
      } else { // context === 'secondary'
          payload.rollType = document.getElementById('secondary-roll-type-hidden').value;
          payload.primaryCritSource = document.getElementById('secondary-crit-source-hidden').value; 
          payload.primaryDamageType = document.getElementById('secondary-damage-type-hidden').value; // Uses data.original_damageType
          payload.primaryMagicSubtype = document.getElementById('secondary-magic-subtype-hidden').value; // Uses data.original_magicSubtype
          payload.primaryResultText = document.getElementById('secondary-primary-result-hidden').value;
          payload.primaryRollValue = document.getElementById('secondary-primary-roll-hidden').value;
          dieTypeForAnim = 'd20'; 
          numDiceForAnim = 1;
      }

      displayRollingAnimation(dieTypeForAnim, numDiceForAnim);

      const animationDuration = 1000;
      const overlay = document.getElementById('dice-animation-overlay');

      try {
          const response = await fetch("{{ url_for('roll_ajax') }}", {
              method: 'POST',
              headers: { 'Content-Type': 'application/json', 'Accept': 'application/json' },
              body: JSON.stringify(payload)
          });
          const data = await response.json();

          if (!response.ok) {
              throw new Error(data.errorMessage || `HTTP error! status: ${response.status}`);
          }
          
          setTimeout(() => {
              if (overlay) overlay.style.display = 'none';
              updateUI(data);
          }, animationDuration);

      } catch (error) {
          console.error('Error during fetch or processing:', error);
          if (overlay) overlay.style.display = 'none';
          updateUI({status: 'error', errorMessage: 'Failed to get roll result: ' + error.message});
      } finally {
            primaryRollBtn.disabled = false;
            if (!secondaryPromptArea.style.display || secondaryPromptArea.style.display === 'none' || secondaryPromptArea.style.visibility === 'hidden'){
                secondaryRollBtn.disabled = true;
            } else {
                secondaryRollBtn.disabled = false; 
            }
      }
  }

  // --- UI Update Function ---
  function updateUI(data) {
      let showPrimary = false;
      let showPrompt = false;
      let showSecondary = false;
      let primaryContent = '';
      let secondaryContent = '';
      let elementToScrollTo = null;

      errorMessageDiv.style.display = 'none';
      errorMessageDiv.textContent = '';
      if (shareButton) shareButton.style.display = 'none';

      if (data.status === 'error') {
          errorMessageDiv.textContent = 'Error: ' + (data.errorMessage || 'Unknown error occurred.');
          errorMessageDiv.style.display = 'block';
          elementToScrollTo = errorMessageDiv;
          if (shareButton) shareButton.style.display = 'none';
          primaryRollBtn.disabled = false; 
          secondaryRollBtn.disabled = true; 
      } else {
          const resultClass = data.selectedRollType === 'fumble' ? 'fumble' : 'result';
          let primaryResultExists = false;
          
          const actualNumDiceRolled = data.numDice || 1;
          const actualDieTypeRolled = data.dieType || 'd20';

          if ((data.selectedRollType === 'fumble' || 
               (data.selectedRollType === 'crit' && (data.selectedCritSource === 'Questionable Arcana' || data.selectedCritSource === 'BCoydog'))) &&
              data.description && data.effect && !data.secondaryResultText) {
              
              const formattedDescription = formatKeywords(data.description);
              const formattedEffect = formatKeywords(data.effect);
              const rollValueToShow = data.rollValue;
              const currentResultBoxClass = data.selectedRollType === 'fumble' ? 'fumble' : 'result';
              
              primaryContent = `
                  <div class="result-box ${currentResultBoxClass}" data-roll-value="${rollValueToShow}" data-roll-type="${data.selectedRollType}" data-crit-source="${data.selectedCritSource}" data-fumble-source="${data.selectedFumbleType}">
                    ${createRollHTML(rollValueToShow, actualNumDiceRolled, actualDieTypeRolled)}
                    <div class="description-box">
                       <p>${formattedDescription}</p> 
                    </div>
                  </div>
                  <div class="result-box secondary"> <h2>Effect</h2>
                    <p>${formattedEffect}</p>
                  </div>`;
              primaryResultExists = true;
          } 
          else if (data.resultText || data.primaryResultForSecondary) {
              const resultTextToShow = data.primaryResultForSecondary || data.resultText || '';
              const formattedResultText = formatKeywords(resultTextToShow);
              const rollValueToShow = data.primaryRollValueForSecondary || data.rollValue;
              // const rollTypeForDataAttr = data.selectedRollType; // Original line for data-roll-type

              let critSourceForPrimaryBoxAtt = data.selectedCritSource; // Default to current response's crit source
              let fumbleSourceForPrimaryBoxAtt = data.selectedFumbleType; // Default to current response's fumble type
              let rollTypeForPrimaryBoxAtt = data.selectedRollType; // Default to current response's roll type

              // If this UI update is for displaying the result of a secondary roll,
              // the primary box's data attributes should reflect the original roll's context.
              if (data.secondaryResultText) {
                  const originalCritSourceFromStorage = document.getElementById('secondary-crit-source-hidden').value;
                  // const originalFumbleSourceFromStorage = document.getElementById('secondary-fumble-source-hidden')?.value; // Assuming a similar field if fumbles had bonuses

                  // If a valid original crit source was stored, use it.
                  if (originalCritSourceFromStorage && originalCritSourceFromStorage !== "null" && originalCritSourceFromStorage !== "undefined" && originalCritSourceFromStorage.trim() !== "") {
                      critSourceForPrimaryBoxAtt = originalCritSourceFromStorage;
                      fumbleSourceForPrimaryBoxAtt = null; // Clear fumble if original was a crit
                      // For consistency, the data-roll-type of the primary box should also reflect it was a 'crit'.
                      // The original roll_type that initiated the crit sequence is what's desired here.
                      // This might need to be stored similarly, or inferred.
                      // For now, setting to 'crit' if originalCritSource is present.
                      rollTypeForPrimaryBoxAtt = 'crit';
                  }
                  // Add similar logic for fumble if fumbles can have secondary rolls affecting the primary box display.
                  // else if (originalFumbleSourceFromStorage && originalFumbleSourceFromStorage !== "null" && ...) {
                  // fumbleSourceForPrimaryBoxAtt = originalFumbleSourceFromStorage;
                  // critSourceForPrimaryBoxAtt = null;
                  // rollTypeForPrimaryBoxAtt = 'fumble';
                  // }
              }

              primaryContent = `
                  <div class="result-box ${resultClass}"
                       data-roll-value="${rollValueToShow}"
                       data-roll-type="${rollTypeForPrimaryBoxAtt}"
                       data-crit-source="${critSourceForPrimaryBoxAtt !== null && critSourceForPrimaryBoxAtt !== undefined ? critSourceForPrimaryBoxAtt : ''}"
                       data-fumble-source="${fumbleSourceForPrimaryBoxAtt !== null && fumbleSourceForPrimaryBoxAtt !== undefined ? fumbleSourceForPrimaryBoxAtt : ''}">
                    ${createRollHTML(rollValueToShow, actualNumDiceRolled, actualDieTypeRolled)}
                    <p>${formattedResultText}</p>
                    ${data.isSecondaryPrompt && !data.secondaryResultText ? '<p class="scroll-note">üëá Bonus Effect!!! üëá</p>' : ''}
                  </div>`;
              primaryResultExists = true;
          }

          if (data.secondaryResultText) { 
              const formattedSecondaryText = formatKeywords(data.secondaryResultText);
              const secondaryRollValue = data.rollValue; 
              secondaryContent = `
                  <div class="result-box secondary" data-roll-value="${secondaryRollValue}" data-roll-type="crit-effect">
                    <h2>‚ú® Bonus Effect</h2>
                     ${createRollHTML(secondaryRollValue, 1, 'd20')}
                     <p>${formattedSecondaryText}</p>
                  </div>`;
              showSecondary = true;
          }

          showPrimary = primaryResultExists;
          showPrompt = data.isSecondaryPrompt && !data.secondaryResultText;

          if (showPrompt) {
              document.getElementById('secondary-prompt-text').textContent = data.secondaryPromptText || 'Bonus Effect!';
              document.getElementById('secondary-roll-type-hidden').value = data.secondaryType; 
              
              document.getElementById('secondary-crit-source-hidden').value = data.selectedCritSource;
              document.getElementById('secondary-damage-type-hidden').value = data.original_damageType || document.getElementById('damage_type').value; 
              document.getElementById('secondary-magic-subtype-hidden').value = data.original_magicSubtype || document.getElementById('magic_subtype').value; 
              
              let originalPrimaryText = data.resultText; 
              if (data.selectedRollType === 'crit' && data.description && data.effect) {
                  originalPrimaryText = data.description + " Effect: " + data.effect; 
              } else if (!data.resultText && data.description) {
                  originalPrimaryText = data.description;
              }
              document.getElementById('secondary-primary-result-hidden').value = originalPrimaryText || "";
              document.getElementById('secondary-primary-roll-hidden').value = data.primaryRollValueForSecondary || data.rollValue || ""; 
              secondaryRollBtn.disabled = false; 
          } else {
              secondaryRollBtn.disabled = true; 
          }

          const isFinalResultShown = showSecondary || (showPrimary && !data.isSecondaryPrompt);
          if (isFinalResultShown && data.status !== 'error') {
              if (shareButton) {
                  shareButton.style.display = 'inline-block';
                  shareButton.disabled = false;
                  const buttonTextSpan = shareButton.querySelector('.button-text');
                  if (buttonTextSpan) { 
                    const currentButtonText = buttonTextSpan.textContent;
                    if (currentButtonText === "Shared!" || currentButtonText === "Sharing...") {
                        const discordIconHTML = '<img src="{{ url_for('static', filename='img/discord-icon.svg') }}" alt="Discord Logo" class="discord-icon">';
                        shareButton.innerHTML = `${discordIconHTML} <span class="button-text">Share Result to Discord</span>`;
                    }
                  }
              }
          } else {
              if (shareButton) shareButton.style.display = 'none';
          }
          primaryRollBtn.disabled = false; 
      }

      primaryResultArea.innerHTML = primaryContent;
      primaryResultArea.style.display = showPrimary ? 'block' : 'none';
      primaryResultArea.style.visibility = showPrimary ? 'visible' : 'hidden';

      secondaryPromptArea.style.display = showPrompt ? 'block' : 'none';
      secondaryPromptArea.style.visibility = showPrompt ? 'visible' : 'hidden';

      secondaryResultArea.innerHTML = secondaryContent;
      secondaryResultArea.style.display = showSecondary ? 'block' : 'none';
      secondaryResultArea.style.visibility = showSecondary ? 'visible' : 'hidden';

      if (showSecondary) elementToScrollTo = secondaryResultArea;
      else if (showPrompt) elementToScrollTo = secondaryPromptArea;
      else if (showPrimary && !data.isSecondaryPrompt) elementToScrollTo = primaryResultArea.querySelector('.result-box:not(.secondary)') || primaryResultArea.querySelector('.result-box') || primaryResultArea;
      else if (data.status === 'error') elementToScrollTo = errorMessageDiv;

      if (elementToScrollTo) {
          const style = window.getComputedStyle(elementToScrollTo);
          if (style.display !== 'none' && style.visibility !== 'hidden') {
               elementToScrollTo.scrollIntoView({ behavior: 'smooth', block: 'center' });
          }
      }
  }

  // --- Share to Discord Function ---
  async function shareResultToDiscord() {
    let resultText = '';
    const primaryResultAreaDiv = document.getElementById('primary-result-area');
    const secondaryResultAreaDiv = document.getElementById('secondary-result-area');

    console.log("shareResultToDiscord called. primaryResultAreaDiv:", primaryResultAreaDiv);

    const primaryResultBoxDiv = primaryResultAreaDiv.querySelector('.result-box:not(.secondary)');
    const secondaryBonusEffectBoxDiv = secondaryResultAreaDiv.querySelector('.result-box.secondary');

    console.log("primaryResultBoxDiv:", primaryResultBoxDiv);

    const primaryCritTextP = primaryResultBoxDiv?.querySelector('p:not(.description-box p)');
    const structuredDescP = primaryResultBoxDiv?.querySelector('.description-box p');
    const structuredEffectP = primaryResultAreaDiv.querySelector('.result-box.secondary > p');

    const secondaryBonusEffectP = secondaryBonusEffectBoxDiv?.querySelector('p');

    const primaryRollValue = primaryResultBoxDiv?.dataset.rollValue;
    const secondaryRollValue = secondaryBonusEffectBoxDiv?.dataset.rollValue;

    const critSource = primaryResultBoxDiv?.dataset.critSource;
    const fumbleSource = primaryResultBoxDiv?.dataset.fumbleSource;
    
    let rollType = null;
    if (critSource && critSource !== "null" && critSource !== "undefined") { 
        rollType = 'crit';
    } else if (fumbleSource && fumbleSource !== "null" && fumbleSource !== "undefined") { 
        rollType = 'fumble';
    }
    console.log("Determined rollType:", rollType, "- Crit Source from data:", critSource, "- Fumble Source from data:", fumbleSource);

    let messagePrefix = "\n\u200b\n";

    if (rollType === 'crit') {
        console.log("Share to Discord: Crit path selected.");
        messagePrefix += `üí• **Critical Hit!** üí•\n\n`;
        let critDescription = "";
        let critEffect = "";

        if (critSource === "Questionable Arcana" || critSource === "BCoydog") {
            critDescription = structuredDescP?.textContent.trim() || "N/A";
            critEffect = structuredEffectP?.textContent.trim() || "N/A";
            console.log("Share to Discord - Structured Crit Desc:", critDescription, "Effect:", critEffect);
            resultText = `${messagePrefix}üé≤ **Rolled:** ${primaryRollValue ?? '?'}\nüìñ **Description:** ${critDescription}\n\n‚ö†Ô∏è **Effect:** ${critEffect}`;
        } else { 
            const primaryText = primaryCritTextP?.textContent.trim() || "N/A";
            console.log("Share to Discord - Sterling Vermin Crit Result:", primaryText);
            resultText = `${messagePrefix}üé≤ **Rolled:** ${primaryRollValue ?? '?'}\n‚ö†Ô∏è **Result:** ${primaryText}`;
        }
        if (secondaryBonusEffectP && secondaryBonusEffectP.textContent.trim() && secondaryRollValue) {
            const secondaryText = secondaryBonusEffectP.textContent.trim();
            console.log("Share to Discord - Bonus Effect:", secondaryText);
            resultText += `\n\nüé≤ **Bonus Roll:** ${secondaryRollValue}\n‚ú® **Effect:** ${secondaryText}`;
        }
    } else if (rollType === 'fumble') {
        console.log("Share to Discord: Fumble path selected. Fumble Source:", fumbleSource);
        messagePrefix += `üíÄ **Fumble!** üíÄ\n\n`;
        
        const fumbleName = structuredDescP?.textContent.trim() || "N/A";
        const fumbleEffect = structuredEffectP?.textContent.trim() || "N/A";

        console.log("Share to Discord - Fumble Name Element:", structuredDescP);
        console.log("Share to Discord - Fumble Effect Element:", structuredEffectP);
        console.log("Share to Discord - Fumble Name Value:", fumbleName);
        console.log("Share to Discord - Fumble Effect Value:", fumbleEffect);
        
        resultText = `${messagePrefix}üé≤ **Rolled:** ${primaryRollValue ?? '?'}\nüò© **Fumble:** ${fumbleName}\n\n‚ö†Ô∏è **Effect:** ${fumbleEffect}`;
    } else {
        console.log("Share to Discord: rollType is null or undefined. Neither crit nor fumble path taken for main content.");
    }
        
    if (!resultText || (resultText.includes('N/A') && !resultText.replace(/N\/A/g, '').replace(messagePrefix, '').trim())) {
        console.log("Share to Discord: Entering fallback logic for resultText construction.");
        const tempPrimaryText = primaryResultAreaDiv.textContent.replace(/(\n|\r|\s{2,})/g, ' ').replace(/Effect/g, '\nEffect').trim();
        const tempSecondaryText = secondaryResultAreaDiv.textContent.replace(/(\n|\r|\s{2,})/g, ' ').trim();
        
        let fallbackPrefix = "\n\u200b\nüé≤ **Result:**\n\n";
        if (rollType === 'crit') fallbackPrefix = "\n\u200b\nüí• **Critical Hit!** üí•\n\n";
        else if (rollType === 'fumble') fallbackPrefix = "\n\u200b\nüíÄ **Fumble!** üíÄ\n\n";

        if (tempPrimaryText && !tempPrimaryText.toLowerCase().includes("bonus effect!!!")) {
             resultText = `${fallbackPrefix}${tempPrimaryText}`;
             if (tempSecondaryText && tempSecondaryText.toLowerCase().includes("bonus effect")) { 
                 resultText += `\n‚ú® ${tempSecondaryText.replace(/Bonus Effect/i, '').trim()}`;
             } else if (tempSecondaryText) {
                 resultText += `\nBonus: ${tempSecondaryText}`;
             }
        } else {
            console.warn("shareResultToDiscord: No valid result text found to share even after fallback.");
            alert('Could not find a complete result to share!');
            const originalButtonHTML_fallback = shareButton.innerHTML; 
            const discordIconHTML_fallback = shareButton.querySelector('.discord-icon')?.outerHTML || '';
             if(shareButton.querySelector('.button-text')?.textContent === "Sharing..."){
                shareButton.innerHTML = originalButtonHTML_fallback;
             }
            shareButton.disabled = false;
            return;
        }
    }
    
    console.log("Final resultText for Discord:", resultText);
    
    const discordIconHTML = shareButton.querySelector('.discord-icon')?.outerHTML || '';
    const originalButtonHTML = shareButton.innerHTML; 

    shareButton.disabled = true;
    shareButton.innerHTML = `${discordIconHTML} <span class="button-text">Sharing...</span>`;

    try {
        const response = await fetch("{{ url_for('share_discord') }}", {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'Accept': 'application/json' },
            body: JSON.stringify({ message: resultText })
        });
        const responseData = await response.json();
        if (response.ok && responseData.status === 'success') {
            shareButton.innerHTML = `${discordIconHTML} <span class="button-text">Shared!</span>`;
            setTimeout(() => {
                if (shareButton.style.display !== 'none') { 
                    shareButton.innerHTML = originalButtonHTML; 
                    shareButton.disabled = false;
                }
            }, 2000);
        } else {
            alert(`Failed to share result: ${responseData?.error || response.statusText}`);
            shareButton.innerHTML = originalButtonHTML;
            shareButton.disabled = false;
        }
    } catch (error) {
         alert('Error contacting server to share result.');
         console.error("Share to Discord error:", error);
         shareButton.innerHTML = originalButtonHTML;
         shareButton.disabled = false;
    }
  }
  
  // --- Roll History Elements & Functions ---
  const showHistoryBtn = document.getElementById('show-history-button');
  const historyOverlay = document.getElementById('history-overlay');
  const closeHistoryBtn = document.getElementById('close-history-modal');
  const historyContent = document.getElementById('history-content');

  async function fetchAndDisplayHistory() {
    try {
        const response = await fetch("{{ url_for('get_roll_history') }}");
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
        const logs = await response.json();

        historyContent.innerHTML = ''; 
        if (logs.length === 0) {
            historyContent.innerHTML = '<p>No rolls recorded yet.</p>';
        } else {
            const ul = document.createElement('ul');
            logs.forEach(log => {
                const li = document.createElement('li');
                const time = log.timestamp ? new Date(log.timestamp).toLocaleString() : 'Timestamp unavailable';
                li.innerHTML = `<strong>${time}</strong> ${log.narrative || 'No narrative.'}`;
                ul.appendChild(li);
            });
            historyContent.appendChild(ul);
        }

        // Use class to trigger animated visibility
        historyOverlay.classList.add('showing');
        document.body.classList.add('modal-open');
        

    } catch (error) {
        console.error('Error fetching roll history:', error);
        historyContent.innerHTML = '<p>Could not load roll history. Please try again later.</p>';
        historyOverlay.classList.add('showing');
        document.body.classList.add('modal-open');
    }
 }

  // --- Initial Setup on Load ---
  window.onload = function() {
    const critSourceSelect = document.getElementById('crit_source');
    if (critSourceSelect) {
        critSourceSelect.addEventListener('change', updateDamageAndMagicTypes);
    }
    // Event Listeners for Info Icons & Modal
    if (critSourceInfoIcon) {
        critSourceInfoIcon.addEventListener('click', () => {
            const selectedCritSource = document.getElementById('crit_source').value;
            showInfoModal('critSources', selectedCritSource);
        });
    }
    if (fumbleTypeInfoIcon) {
        fumbleTypeInfoIcon.addEventListener('click', () => {
            const selectedFumbleSource = document.getElementById('fumbleType').value;
            showInfoModal('fumbleSources', selectedFumbleSource);
        });
    }
    if (infoModalCloseButton) {
        infoModalCloseButton.addEventListener('click', hideInfoModal);
    }
    if (infoModalOverlay) {
        infoModalOverlay.addEventListener('click', (event) => {
            if (event.target === infoModalOverlay) { // Click on overlay itself
                hideInfoModal();
            }
        });
    }
function closeHistoryOverlay() {
    if (historyOverlay) {
        historyOverlay.classList.remove('showing');
        document.body.classList.remove('modal-open');
    }
}

// History listeners
if (showHistoryBtn) {
    showHistoryBtn.addEventListener('click', fetchAndDisplayHistory);
}

if (closeHistoryBtn) {
    closeHistoryBtn.addEventListener('click', closeHistoryOverlay);
}

if (historyOverlay) {
    historyOverlay.addEventListener('click', (event) => {
        if (event.target === historyOverlay) {
            closeHistoryOverlay();
        }
    });
}
    
    toggleFields(); // Initial setup of visible fields and dropdowns
};
</script>

</body>
</html>